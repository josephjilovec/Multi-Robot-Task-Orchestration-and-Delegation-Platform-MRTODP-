```julia
# backend/julia/neural/network.jl
# Purpose: Implements neural network-based skills for MRTODP using Julia 1.10.0 and Flux.jl (0.14.0).
# Defines functions to create and train neural networks for tasks (e.g., object recognition) based on
# instructions from backend/lisp/planner.lisp. Supports GPU acceleration via CUDA.jl (5.4.0) and
# TensorRT for optimized inference. Interfaces with SQLite for task storage and includes robust error
# handling for invalid specifications, ensuring reliability for advanced users (e.g., robotics engineers).

using Flux
using CUDA
using JSON
using SQLite
using Logging
using TensorRT

# Configure logging for debugging and error tracking
global_logger(ConsoleLogger(stderr, Logging.Info))

# Neural network configuration struct
struct NeuralSkill
    model::Chain
    device::Function
    task_type::String
    db::SQLite.DB
end

"""
    create_neural_skill(task_type::String, spec::Dict) -> NeuralSkill

Create a neural network for a specific task type based on specifications from planner.lisp.
The spec dict contains architecture details (e.g., layers, activations).
Uses CUDA for GPU acceleration if available, falling back to CPU otherwise.
Stores task metadata in SQLite database.
"""
function create_neural_skill(task_type::String, spec::Dict)::NeuralSkill
    try
        # Validate task type and specification
        if !haskey(spec, "layers") || !haskey(spec, "activations")
            error("Invalid specification: missing 'layers' or 'activations'")
        end
        if isempty(task_type)
            error("Task type cannot be empty")
        end

        # Connect to SQLite database
        db_path = "mrtodp_tasks.db"
        if !isfile(db_path)
            error("SQLite database not found at $db_path")
        end
        db = SQLite.DB(db_path)

        # Define neural network architecture
        layers = []
        for (size, activation) in zip(spec["layers"], spec["activations"])
            if activation == "relu"
                push!(layers, Dense(size[1] => size[2], relu))
            elseif activation == "sigmoid"
                push!(layers, Dense(size[1] => size[2], sigmoid))
            else
                error("Unsupported activation function: $activation")
            end
        end
        model = Chain(layers...)

        # Move to GPU if available
        device = CUDA.functional() ? gpu : cpu
        model = model |> device
        @info "Created neural network for task $task_type on $(CUDA.functional() ? "GPU" : "CPU")"

        # Store task metadata in database
        SQLite.execute(db, """
            INSERT OR IGNORE INTO neural_skills (task_type, architecture, status)
            VALUES (?, ?, ?)
        """, (task_type, JSON.json(spec), "created"))

        return NeuralSkill(model, device, task_type, db)
    catch e
        @error "Failed to create neural skill for $task_type: $e"
        rethrow()
    end
end

"""
    train_neural_skill(skill::NeuralSkill, data::Matrix, labels::Matrix, epochs::Int=10)

Train the neural skill model using provided data and labels.
Supports GPU acceleration and TensorRT optimization for inference.
Saves trained model state to SQLite database.
"""
function train_neural_skill(skill::NeuralSkill, data::Matrix, labels::Matrix, epochs::Int=10)
    try
        # Validate inputs
        if size(data, 2) != size(labels, 2)
            error("Mismatch between data and labels dimensions")
        end
        if epochs <= 0
            error("Epochs must be positive")
        end

        # Prepare data for training
        data = skill.device(data)
        labels = skill.device(labels)
        loader = Flux.DataLoader((data, labels), batchsize=32, shuffle=true)

        # Define optimizer and loss
        opt = ADAM(0.001)
        loss(x, y) = Flux.crossentropy(skill.model(x), y)

        # Train model
        @info "Training neural skill for $(skill.task_type) with $epochs epochs"
        for epoch in 1:epochs
            Flux.train!(loss, Flux.params(skill.model), loader, opt)
            avg_loss = mean(loss(x, y) for (x, y) in loader)
            @info "Epoch $epoch: Average loss = $avg_loss"
        end

        # Optimize with TensorRT for inference
        if CUDA.functional()
            try
                trt_model = TensorRT.convert(skill.model)
                @info "Converted model to TensorRT for optimized inference"
                # Update model in skill (simplified; TensorRT integration may vary)
                skill.model = trt_model
            catch e
                @warn "TensorRT optimization failed: $e. Continuing with Flux model."
            end
        end

        # Save trained model state
        model_state = Flux.state(skill.model) |> cpu
        SQLite.execute(skill.db, """
            UPDATE neural_skills
            SET status = ?, model_state = ?
            WHERE task_type = ?
        """, ("trained", JSON.json(model_state), skill.task_type))
        @info "Saved trained model state for $(skill.task_type)"
    catch e
        @error "Training failed for $(skill.task_type): $e"
        rethrow()
    end
end

"""
    infer_neural_skill(skill::NeuralSkill, input::Matrix) -> Matrix

Perform inference using the trained neural skill model.
Returns predictions for the given input.
"""
function infer_neural_skill(skill::NeuralSkill, input::Matrix)::Matrix
    try
        input = skill.device(input)
        predictions = skill.model(input) |> cpu
        @info "Inference completed for $(skill.task_type)"
        return predictions
    catch e
        @error "Inference failed for $(skill.task_type): $e"
        rethrow()
    end
end

# Example usage
function main()
    try
        # Example specification from planner.lisp (e.g., for object recognition)
        spec = Dict(
            "layers" => [(784, 128), (128, 10)], # Input: 784 (e.g., flattened image), Output: 10 classes
            "activations" => ["relu", "softmax"]
        )
        task_type = "object_recognition"

        # Create and train neural skill
        skill = create_neural_skill(task_type, spec)
        data = rand(Float32, 784, 1000) # Dummy data (e.g., MNIST-like images)
        labels = rand(Float32, 10, 1000) # Dummy labels (one-hot encoded)
        train_neural_skill(skill, data, labels, 5)

        # Perform inference
        test_input = rand(Float32, 784, 10)
        predictions = infer_neural_skill(skill, test_input)
        println("Predictions: ", predictions)
    catch e
        @error "Example usage failed: $e"
        exit(1)
    end
end

if abspath(PROGRAM_FILE) == @__FILE__
    main()
end
```
